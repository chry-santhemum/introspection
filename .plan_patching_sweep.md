# Patching Layer Sweep - Implementation Plan (FINAL)

## Overview

Two separate scripts for pipelining GPU work and API judging:

1. **`patching_sweep_success_failure_rollouts.py`** - Runs on GPU cluster, generates all rollouts
2. **`patching_sweep_success_failure_judge.py`** - Runs anywhere, judges rollouts and creates plots

---

## Files Modified/Created

### Modified: `utils_judge.py`

Added parameters to `judge_main()`:
- `judge_type: Literal["detection_identification", "detection"]` - which judge prompt to use
- `judge_model: str` - model for judging
- `reasoning: str | int` - reasoning level
- `enable_cache: bool` - whether to cache API responses

### Created: `patching_sweep_success_failure_rollouts.py`

Constants (shared via import):
- `STEER_LAYER = 38`
- `PATCH_LAYERS = [40, 41, ..., 60]`
- `BATCH_SIZE = 64`
- `POSITIVE_WORDS` (8 words)
- `NEGATIVE_WORDS` (10 words)
- `EXPERIMENTS` (4 experiment configs)
- `BASE_DIR = Path("patching_layer_sweep")`

Functions:
- `run_patching_experiment()` - single source/target word pair
- `run_experiment_for_layer()` - all word combinations for one layer
- `main()` - loops over experiments and layers

### Created: `patching_sweep_success_failure_judge.py`

Imports constants from `patching_sweep_success_failure_rollouts.py`

Judge config:
- `JUDGE_MODEL = "openai/gpt-5-nano"`
- `REASONING = "medium"`
- `ENABLE_CACHE = False`
- `force_caller = "openrouter"`

Functions:
- `create_key_to_word_mapping()` - maps result keys to target words for judging
- `create_sweep_plot()` - creates layer sweep visualization
- `run_all_judging()` - async main loop
- `main()` - entry point with `asyncio.run()`

---

## Experiment Definitions

| Name | Source Steering | Target Steering | Pairs? | Judge Type |
|------|----------------|-----------------|--------|------------|
| failure_to_success | negative | positive | Yes (80) | detection_identification |
| success_to_failure | positive | negative | Yes (80) | detection_identification |
| steered_to_unsteered | positive | None | No (8) | detection |
| unsteered_to_steered | None | positive | No (8) | detection |

---

## Output Directory Structure

```
patching_layer_sweep/
├── failure_to_success/
│   ├── layer_40/
│   │   ├── rollouts.json
│   │   ├── judgments_detection.json
│   │   ├── judgments_coherence.json
│   │   └── judge_scores.json
│   ├── layer_41/
│   │   └── ...
│   ├── layer_60/
│   │   └── ...
│   ├── all_layer_scores.json
│   └── sweep_plot.png
├── success_to_failure/
│   └── ... (same structure)
├── steered_to_unsteered/
│   └── ... (same structure)
└── unsteered_to_steered/
    └── ... (same structure)
```

---

## Visualization

### Experiments A & B (pair-based)
- **Dim lines (80)**: One per (source, target) pair, alpha=0.15, colored by destination
- **Bold lines (8 or 10)**: One per destination word, averaged over all sources
- **Legend**: Destination words only
- **Y-axis**: "Coherent & Detect+Identify Rate"

### Experiments C & D (single-word)
- **Dim lines (8)**: One per positive word, alpha=0.5
- **Bold line (1)**: Mean across all words
- **Legend**: All 8 words + "Mean"
- **Y-axis**: "Coherent & Detect Rate"

---

## Usage

```bash
# On GPU cluster
python patching_sweep_success_failure_rollouts.py

# Transfer rollouts to local machine, then:
python patching_sweep_success_failure_judge.py
```

Both scripts support resumability - they skip already-completed layers.

---

## Judge Call Count

| Experiment | Pairs/Words | Samples | Layers | Judge Calls (×2) |
|------------|-------------|---------|--------|------------------|
| A | 80 | 64 | 21 | 215,040 |
| B | 80 | 64 | 21 | 215,040 |
| C | 8 | 64 | 21 | 21,504 |
| D | 8 | 64 | 21 | 21,504 |
| **Total** | | | | **473,088** |
